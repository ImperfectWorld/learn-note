https://doc.codingdict.com/webpack-cn-doc/loaders/url-loader/

### 打包工具解决什么问题

- ES-Module 的浏览器兼容性问题
- 模块文件过多导致频繁发送网络请求的问题
- 资源文件模块化问题

### webpack运行机制
Webpack 在整个打包的过程中：
- 通过 Loader 处理特殊类型资源的加载，例如加载样式、图片；
- 通过 Plugin 实现各种自动化的构建任务，例如自动压缩、自动发布；

Webpack 启动后，
- 会根据我们的配置，找到项目中的某个指定文件（一般这个文件都会是一个 JS 文件）作为入口。
- 然后顺着入口文件中的代码，根据代码中出现的 import（ES Modules）或者是 require（CommonJS）之类的语句，解析推断出来这个文件所依赖的资源模块
- 然后再分别去解析每个资源模块的依赖，周而复始，最后形成整个项目中所有用到的文件之间的依赖关系树
- Webpack 会遍历（递归）这个依赖树，找到每个节点对应的资源文件
- 然后根据配置选项中的 Loader 配置，交给对应的 Loader 去加载这个模块，最后将加载的结果放入 bundle.js（打包结果）中

> 对于依赖模块中无法通过 JavaScript 代码表示的资源模块，例如图片或字体文件，
> 一般的 Loader 会将它们单独作为资源文件拷贝到输出目录中，然后将这个资源文件所对应的访问路径作为这个模块的导出成员暴露给外部。

自定义插件机制，它并不会影响 Webpack 的核心工作过程，只是 Webpack 为了提供一个强大的扩展能力，
它为整个工作过程的每个环节都预制了一个钩子，也就是说我们可以通过插件往 Webpack 工作过程的任意环节植入一些自定义的任务，从而扩展 Webpack 打包功能以外的能力。

### 工作原理剖析

- Webpack CLI 启动打包流程；
- 载入 Webpack 核心模块，创建 Compiler 对象；
- 使用 Compiler 对象开始编译整个项目；
- 从入口文件开始，解析模块依赖，形成依赖关系树；
- 递归依赖树，将每个模块交给对应的 Loader 处理；
- 合并 Loader 处理完的结果，将打包结果输出到 dist 目录。

### webpack 优势

- 扩展性强，插件机制完善
- webpack 是以 commonJS 的形式来书写脚本，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移

### webpack 无法避免的问题：

- 【速度慢】本地开发环境webpack也是需要先打包，然后服务器运行的是打包后的文件，所以代码量很大的项目就会有启服务很慢的现象，
- 【配置文件复杂】需要一系列的插件完成很多简单的操作（比如加载 CSS 等），而且配置文件非常复杂。
- 【包体积大】由于 Webpack 需要使用 polyfill 来加载模块，因此它生成的包远远大于其他使用 ESM 和现代 JavaScript 语法的包。
- 热更新：Webpack 的热更新会以当前修改的文件为入口重新 build 打包，所有涉及到的依赖也都会被重新加载一次。
虽然webpack也采用的是局部热更新并且是有缓存机制的，但是还是需要重新打包所以很大的代码项目是真的有卡顿的现象

### Vite 的特点
- 快速的冷启动
- 即时的模块热更新
- 真正的按需编译

### 与其他vite对比


### webpack代码分割

### webpack打包优化方法思路
- 拆包，限制构建范围，减少资源搜索时间，无关资源不要参与构建（注意包引入的顺序）
- 使用增量构建而不是全量构建
- 减小打包文件体积
  - 通过提取公共代码块
  - 将vue、jquery等放到cdn上减少包体积
  - 代码压缩
- happypack
  - 的原理是让loader可以多进程去处理文件
  - 利用缓存来使得rebuild 更快
- 在webpack的整个构建过程中，有多个地方提供了缓存的机会，如果我们打开了这些缓存，会大大加速我们的构建

[webpack优化解决项目体积大、打包时间长、刷新时间长问题！](https://juejin.cn/post/6844904174937718792)

[webpack打包优化，整理较为系统，逻辑清晰](https://juejin.cn/post/6844904071736852487)

![image](https://user-images.githubusercontent.com/11763399/157178342-a5cb76ae-9067-4d6d-9bee-57571ce2fc7e.png)


### elementui 按需引入实现方法
